<!DOCTYPE html> 
<html> 
<head> 
<title>Chess Game</title> 
<!-- Chessground CSS --> 
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chessground@9.2.1/assets/chessground.base.css" /> 
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chessground@9.2.1/assets/chessground.brown.css" />
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chessground@9.2.1/assets/chessground.cburnett.css" />
<script th:inline="javascript">
    const ROOM_ID = /*[[${room.id}]]*/ 0;
    const USER_ID = /*[[${user.id}]]*/ 0;
    const HOST_USER_ID = /*[[${room.hostUser.id}]]*/ 0;

    const ROLE = (USER_ID === HOST_USER_ID) ? 'host' : 'guest';
    const MY_COLOR = (ROLE === 'host') ? 'white' : 'black';
</script>
  <!-- SockJS & STOMP --> <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js">
  </script> <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script> 
  <!-- Chess.js (ë£° ì—”ì§„) --> <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  
  
   <style> #board { width: 400px; height: 400px; margin-top: 20px; } </style> 
   </head>
<body> <h2>ì‹¤ì‹œê°„ ì²´ìŠ¤ ê²Œì„</h2> <div id="board"></div> <button onclick="copyPgn()">ğŸ“‹ ê¸°ë³´ ë³µì‚¬</button> 





<script type="module">
import { Chessground } from "https://cdn.jsdelivr.net/npm/chessground@9.2.1/dist/chessground.min.js";

const boardElement = document.getElementById("board");
const socket = new SockJS("/ws");
const stompClient = Stomp.over(socket);

const game = new window.Chess();
let gameEnded = false;
let moveHistory = [];

/** ì²´ìŠ¤ë³´ë“œ ì´ˆê¸°í™” **/
const ground = Chessground(boardElement, {
    orientation: MY_COLOR,
    draggable: { enabled: true },
    movable: {
        color: null,
        dests: new Map(),
        events: {
            after: (from, to) => {
                if (gameEnded) return;

                const legalMoves = game.moves({ square: from, verbose: true });
                const move = legalMoves.find(m => m.to === to);
                if (!move) {
                    console.log("âŒ ë¶ˆë²• ìˆ˜");
                    return;
                }

                game.move({ from, to });
                moveHistory.push(move.san);

                const fen = game.fen();

                // ì„œë²„ë¡œ ìˆ˜ ì „ë‹¬
                stompClient.send("/app/move", {}, JSON.stringify({
                    roomId: ROOM_ID,
                    fen: fen,
                    pgn: "" // í•„ìš”ì‹œ ì„œë²„ì—ì„œ ì²˜ë¦¬
                }));

                ground.set({ movable: { color: null, dests: new Map() } });
            }
        }
    },
    highlight: { lastMove: true, check: true }
});

/** ì´ë™ ê°€ëŠ¥ì„± ë° í„´ ê°±ì‹  **/
function updateMovable(playTurn) {
    if (gameEnded) return;

    const isMyTurn = (playTurn.toLowerCase() === MY_COLOR);
    const dests = new Map();

    if (isMyTurn) {
        game.board().forEach((row, rankIdx) => {
            row.forEach((piece, fileIdx) => {
                if (piece && piece.color === MY_COLOR[0]) {
                    const square = String.fromCharCode(97 + fileIdx) + (8 - rankIdx);
                    const moves = game.moves({ square: square, verbose: true });
                    if (moves.length > 0) {
                        dests.set(square, moves.map(m => m.to));
                    }
                }
            });
        });
    }

    ground.set({
        movable: {
            color: isMyTurn ? MY_COLOR : null,
            dests: dests
        },
        turnColor: playTurn.toLowerCase()
    });
}

/** ê²Œì„ ì¢…ë£Œ í›„ ì´ë™ ë¹„í™œì„±í™” **/
function disableMoves() {
    ground.set({ movable: { color: null, dests: new Map() } });
}

/** ê²°ê³¼ ì•Œë¦¼ (ìŠ¹/íŒ¨/ë¬´) **/
function showResult(resultType) {
    gameEnded = true;
    disableMoves();

    if (resultType === "draw") {
        alert("ğŸ¤ ë¬´ìŠ¹ë¶€ì…ë‹ˆë‹¤.");
    } else {
        const win = resultType.toLowerCase() === MY_COLOR;
        alert(win ? "ğŸ‰ ìŠ¹ë¦¬í•˜ì…¨ìŠµë‹ˆë‹¤!" : "ğŸ˜¢ íŒ¨ë°°í•˜ì…¨ìŠµë‹ˆë‹¤.");
    }
}

/** PGN ë³µì‚¬ ê¸°ëŠ¥ **/
window.copyPgn = function () {
    const formatted = formatMoves(moveHistory);
    navigator.clipboard.writeText(formatted)
        .then(() => alert("ğŸ“‹ ê¸°ë³´ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤"))
        .catch(err => alert("âŒ ë³µì‚¬ ì‹¤íŒ¨: " + err));
};

/** PGN ìˆ˜ìˆœ í¬ë§·íŒ… **/
function formatMoves(moves) {
    let result = "";
    for (let i = 0; i < moves.length; i++) {
        if (i % 2 === 0) result += (Math.floor(i / 2) + 1) + ". ";
        result += moves[i] + " ";
    }
    return result.trim();
}

/** ë©”ì‹œì§€ ìˆ˜ì‹  ë° ì²˜ë¦¬ **/
stompClient.connect({}, () => {
    console.log("âœ… WebSocket ì—°ê²°ë¨");

    stompClient.subscribe(`/topic/room/${ROOM_ID}`, message => {
        const data = JSON.parse(message.body);

        try {
            game.load(data.fen);
        } catch (err) {
            console.error("âŒ FEN ë¡œë”© ì‹¤íŒ¨:", err.message);
            return;
        }

        ground.set({ fen: data.fen });

        if (game.in_checkmate()) {
            const winner = data.playTurn === "WHITE" ? "black" : "white";
            showResult(winner);
            return;
        } else if (game.in_draw()) {
            showResult("draw");
            return;
        }

        updateMovable(data.playTurn);
    });

    // ì‹œì‘ ì‹œ í•­ìƒ í°ìƒ‰ ì°¨ë¡€ë¶€í„° ì‹œì‘
    updateMovable("WHITE");
});
</script>




 </body>
 
 </html>